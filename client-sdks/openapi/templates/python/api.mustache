# coding: utf-8

{{>partial_header}}

import warnings
import json
import re
import importlib
import sys
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

{{#imports}}
{{import}}
{{/imports}}

from {{packageName}}.api_client import ApiClient, RequestSerialized
from {{packageName}}.api_response import ApiResponse
from {{packageName}}.rest import RESTResponseType
from {{packageName}}.stream import Stream


{{#operations}}
class {{classname}}:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

        # Child API attributes (set by LlamaStackClient based on x-nesting-path)
{{#operation}}{{#vendorExtensions.x-nesting-path}}{{#-first}}{{#tags}}{{#-first}}{{#vendorExtensions.x-nesting-path}}{{^-last}}        self.{{.}}: Optional[Any] = None  # Next in nesting path
{{/-last}}{{/vendorExtensions.x-nesting-path}}{{/-first}}{{/tags}}{{/-first}}{{/vendorExtensions.x-nesting-path}}{{/operation}}
{{#operation}}

{{! Skip Pydantic validation for multipart/form-data endpoints to allow file-like objects }}
{{^hasFormParams}}    @validate_call
{{/hasFormParams}}
    {{#async}}async {{/async}}def {{#vendorExtensions.x-operation-name}}{{vendorExtensions.x-operation-name}}{{/vendorExtensions.x-operation-name}}{{^vendorExtensions.x-operation-name}}{{operationId}}{{/vendorExtensions.x-operation-name}}{{>partial_api_args}} -> {{#hasProduces}}{{#vendorExtensions.x-unwrap-list-response}}{{#returnType}}{{#returnContainer}}Union[{{{returnBaseType}}}, Stream[{{{returnBaseType}}}]]{{/returnContainer}}{{^returnContainer}}Union[{{{returnType}}}, Stream[{{{returnType}}}]]{{/returnContainer}}{{/returnType}}{{^returnType}}Union[None, Stream[None]]{{/returnType}}{{/vendorExtensions.x-unwrap-list-response}}{{^vendorExtensions.x-unwrap-list-response}}Union[{{{returnType}}}{{^returnType}}None{{/returnType}}, Stream[{{{returnType}}}{{^returnType}}None{{/returnType}}]]{{/vendorExtensions.x-unwrap-list-response}}{{/hasProduces}}{{^hasProduces}}{{{returnType}}}{{^returnType}}None{{/returnType}}{{/hasProduces}}:
{{>partial_api}}

        response_data = {{#async}}await {{/async}}self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )

        # Check if this is a streaming response
        content_type = response_data.response.headers.get('Content-Type', '')
        if 'text/event-stream' in content_type:
            # Get the response model type - for streaming, use the Stream variant
            response_type_str = _response_types_map.get('200')
            # Convert OpenAIResponseObject to OpenAIResponseObjectStream for streaming
            if response_type_str and response_type_str.endswith('Object'):
                stream_type_str = response_type_str + 'Stream'
            else:
                stream_type_str = response_type_str

            # Create a decoder that uses ApiClient's deserializer
            def stream_decoder(data_str: str) -> Any:
                if not data_str:
                    return None
                try:
                    data = json.loads(data_str)
                    if stream_type_str:
                        # Use discriminator to directly deserialize to the specific event type
                        event_type = data.get('type')
                        if event_type:
                            # Map discriminator value to class name
                            # e.g., "response.created" -> "OpenAIResponseObjectStreamResponseCreated"
                            # Handle underscores: "response.output_item.added" -> "ResponseOutputItemAdded"
                            type_parts = event_type.replace('_', '.').split('.')
                            # Capitalize each part: response.created -> ResponseCreated
                            class_suffix = ''.join(part.capitalize() for part in type_parts)
                            # Get base type name from stream_type_str
                            # e.g., OpenAIResponseObjectStream -> OpenAIResponseObjectStream
                            specific_type_str = stream_type_str + class_suffix

                            try:
                                # Directly instantiate the model class without going through deserializer
                                # This avoids oneOf validation issues
                                # Convert PascalCase to snake_case properly
                                # Handle sequences like "OpenAI" -> "open_ai"
                                module_name = re.sub('([A-Z]+)([A-Z][a-z])', r'\1_\2', specific_type_str)
                                module_name = re.sub('([a-z0-9])([A-Z])', r'\1_\2', module_name).lower()
                                model_module = importlib.import_module('{{packageName}}.models.' + module_name)
                                model_class = getattr(model_module, specific_type_str)
                                # Use from_dict which properly handles nested oneOf models
                                return model_class.from_dict(data)
                            except Exception as e_specific:
                                pass

                        # Fall back to generic union deserialization
                        try:
                            deserialized = self.api_client._ApiClient__deserialize(data, stream_type_str)
                            # Unwrap discriminated unions to return the actual instance
                            if hasattr(deserialized, 'actual_instance') and deserialized.actual_instance is not None:
                                return deserialized.actual_instance
                            return deserialized
                        except (ValueError, Exception) as e1:
                            # Try lenient from_dict fallback for streaming chunks
                            try:
                                # Convert PascalCase to snake_case properly (same as above)
                                module_name = re.sub('([A-Z]+)([A-Z][a-z])', r'\1_\2', stream_type_str)
                                module_name = re.sub('([a-z0-9])([A-Z])', r'\1_\2', module_name).lower()
                                model_module = importlib.import_module('{{packageName}}.models.' + module_name)
                                model_class = getattr(model_module, stream_type_str)
                                deserialized = model_class.from_dict(data)
                                # Unwrap discriminated unions to return the actual instance
                                if hasattr(deserialized, 'actual_instance') and deserialized.actual_instance is not None:
                                    return deserialized.actual_instance
                                return deserialized
                            except (ValueError, Exception) as e2:
                                # Streaming events may have different schemas than the response type
                                # Return raw dict for events that don't match the expected schema
                                return data
                    return data
                except json.JSONDecodeError:
                    return data_str

            # Return a Stream object for streaming responses
            return Stream(
                response=response_data.response,
                client=self.api_client,
                decoder=stream_decoder,
            )

        {{#async}}await {{/async}}response_data.read()
        _deserialized = self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data
        # Unwrap List*Response wrappers to return the data field directly
        {{#vendorExtensions.x-unwrap-list-response}}
        if _deserialized is not None and hasattr(_deserialized, 'data'):
            return _deserialized.data
        {{/vendorExtensions.x-unwrap-list-response}}
        return _deserialized

{{! Skip Pydantic validation for multipart/form-data endpoints }}
{{^hasFormParams}}    @validate_call
{{/hasFormParams}}
    {{#async}}async {{/async}}def {{#vendorExtensions.x-operation-name}}{{vendorExtensions.x-operation-name}}{{/vendorExtensions.x-operation-name}}{{^vendorExtensions.x-operation-name}}{{operationId}}{{/vendorExtensions.x-operation-name}}_with_http_info{{>partial_api_args}} -> {{#hasProduces}}Union[ApiResponse[{{{returnType}}}{{^returnType}}None{{/returnType}}], Stream[{{{returnType}}}{{^returnType}}None{{/returnType}}]]{{/hasProduces}}{{^hasProduces}}ApiResponse[{{{returnType}}}{{^returnType}}None{{/returnType}}]{{/hasProduces}}:
{{>partial_api}}

        response_data = {{#async}}await {{/async}}self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )

        # Check if this is a streaming response
        content_type = response_data.response.headers.get('Content-Type', '')
        if 'text/event-stream' in content_type:
            # Get the response model type - for streaming, use the Stream variant
            response_type_str = _response_types_map.get('200')
            # Convert OpenAIResponseObject to OpenAIResponseObjectStream for streaming
            if response_type_str and response_type_str.endswith('Object'):
                stream_type_str = response_type_str + 'Stream'
            else:
                stream_type_str = response_type_str

            # Create a decoder that uses ApiClient's deserializer
            def stream_decoder(data_str: str) -> Any:
                if not data_str:
                    return None
                try:
                    data = json.loads(data_str)
                    if stream_type_str:
                        # Use discriminator to directly deserialize to the specific event type
                        event_type = data.get('type')
                        if event_type:
                            # Map discriminator value to class name
                            # e.g., "response.created" -> "OpenAIResponseObjectStreamResponseCreated"
                            # Handle underscores: "response.output_item.added" -> "ResponseOutputItemAdded"
                            type_parts = event_type.replace('_', '.').split('.')
                            # Capitalize each part: response.created -> ResponseCreated
                            class_suffix = ''.join(part.capitalize() for part in type_parts)
                            # Get base type name from stream_type_str
                            # e.g., OpenAIResponseObjectStream -> OpenAIResponseObjectStream
                            specific_type_str = stream_type_str + class_suffix

                            try:
                                # Directly instantiate the model class without going through deserializer
                                # This avoids oneOf validation issues
                                # Convert PascalCase to snake_case properly
                                # Handle sequences like "OpenAI" -> "open_ai"
                                module_name = re.sub('([A-Z]+)([A-Z][a-z])', r'\1_\2', specific_type_str)
                                module_name = re.sub('([a-z0-9])([A-Z])', r'\1_\2', module_name).lower()
                                model_module = importlib.import_module('{{packageName}}.models.' + module_name)
                                model_class = getattr(model_module, specific_type_str)
                                # Use from_dict which properly handles nested oneOf models
                                return model_class.from_dict(data)
                            except Exception as e_specific:
                                pass

                        # Fall back to generic union deserialization
                        try:
                            deserialized = self.api_client._ApiClient__deserialize(data, stream_type_str)
                            # Unwrap discriminated unions to return the actual instance
                            if hasattr(deserialized, 'actual_instance') and deserialized.actual_instance is not None:
                                return deserialized.actual_instance
                            return deserialized
                        except (ValueError, Exception) as e1:
                            # Try lenient from_dict fallback
                            try:
                                # Convert PascalCase to snake_case properly (same as above)
                                module_name = re.sub('([A-Z]+)([A-Z][a-z])', r'\1_\2', stream_type_str)
                                module_name = re.sub('([a-z0-9])([A-Z])', r'\1_\2', module_name).lower()
                                model_module = importlib.import_module('{{packageName}}.models.' + module_name)
                                model_class = getattr(model_module, stream_type_str)
                                deserialized = model_class.from_dict(data)
                                # Unwrap discriminated unions to return the actual instance
                                if hasattr(deserialized, 'actual_instance') and deserialized.actual_instance is not None:
                                    return deserialized.actual_instance
                                return deserialized
                            except (ValueError, Exception) as e2:
                                # Streaming events may have different schemas than the response type
                                # Return raw dict for events that don't match the expected schema
                                return data
                    return data
                except json.JSONDecodeError:
                    return data_str

            # Return a Stream object for streaming responses
            return Stream(
                response=response_data.response,
                client=self.api_client,
                decoder=stream_decoder,
            )

        {{#async}}await {{/async}}response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

{{! Skip Pydantic validation for multipart/form-data endpoints }}
{{^hasFormParams}}    @validate_call
{{/hasFormParams}}
    {{#async}}async {{/async}}def {{#vendorExtensions.x-operation-name}}{{vendorExtensions.x-operation-name}}{{/vendorExtensions.x-operation-name}}{{^vendorExtensions.x-operation-name}}{{operationId}}{{/vendorExtensions.x-operation-name}}_without_preload_content{{>partial_api_args}} -> RESTResponseType:
{{>partial_api}}

        response_data = {{#async}}await {{/async}}self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _{{#vendorExtensions.x-operation-name}}{{vendorExtensions.x-operation-name}}{{/vendorExtensions.x-operation-name}}{{^vendorExtensions.x-operation-name}}{{operationId}}{{/vendorExtensions.x-operation-name}}_serialize(
        self,
        {{#allParams}}
        {{paramName}},
        {{/allParams}}
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        {{#servers.0}}
        _hosts = [{{#servers}}
            '{{{url}}}'{{^-last}},{{/-last}}{{/servers}}
        ]
        _host = _hosts[_host_index]
        {{/servers.0}}
        {{^servers.0}}
        _host = None
        {{/servers.0}}

        _collection_formats: Dict[str, str] = {
            {{#allParams}}
            {{#isArray}}
            '{{baseName}}': '{{collectionFormat}}',
            {{/isArray}}
            {{/allParams}}
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
{{#pathParams}}
        if {{paramName}} is not None:
            _path_params['{{baseName}}'] = {{paramName}}{{#isEnumRef}}.value{{/isEnumRef}}
{{/pathParams}}
        # process the query parameters
{{#queryParams}}
        if {{paramName}} is not None:
            {{#isDateTime}}
            if isinstance({{paramName}}, datetime):
                _query_params.append(
                    (
                        '{{baseName}}',
                        {{paramName}}.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('{{baseName}}', {{paramName}}))
            {{/isDateTime}}
            {{#isDate}}
            if isinstance({{paramName}}, date):
                _query_params.append(
                    (
                        '{{baseName}}',
                        {{paramName}}.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('{{baseName}}', {{paramName}}))
            {{/isDate}}
            {{^isDateTime}}{{^isDate}}
            _query_params.append(('{{baseName}}', {{paramName}}{{#isEnumRef}}.value{{/isEnumRef}}))
            {{/isDate}}{{/isDateTime}}
{{/queryParams}}
        # process the header parameters
{{#headerParams}}
        if {{paramName}} is not None:
            _header_params['{{baseName}}'] = {{paramName}}
{{/headerParams}}
        # process the form parameters
{{#formParams}}
        if {{paramName}} is not None:
            {{#isFile}}
            _files['{{{baseName}}}'] = {{paramName}}
            {{/isFile}}
            {{^isFile}}
            _form_params.append(('{{{baseName}}}', {{paramName}}))
            {{/isFile}}
{{/formParams}}
        # process the body parameter
{{#bodyParam}}
        if {{paramName}} is not None:
            {{#isBinary}}
            # convert to byte array if the input is a file name (str)
            if isinstance({{paramName}}, str):
                with open({{paramName}}, "rb") as _fp:
                    _body_params = _fp.read()
            elif isinstance({{paramName}}, tuple):
                # drop the filename from the tuple
                _body_params = {{paramName}}[1]
            else:
                _body_params = {{paramName}}
            {{/isBinary}}
            {{^isBinary}}
            _body_params = {{paramName}}
            {{/isBinary}}
{{/bodyParam}}

        {{#constantParams}}
        {{#isQueryParam}}
        # Set client side default value of Query Param "{{baseName}}".
        _query_params.append(('{{baseName}}', {{#_enum}}'{{{.}}}'{{/_enum}}))
        {{/isQueryParam}}
        {{#isHeaderParam}}
        # Set client side default value of Header Param "{{baseName}}".
        _header_params['{{baseName}}'] = {{#_enum}}'{{{.}}}'{{/_enum}}
        {{/isHeaderParam}}
        {{/constantParams}}

        {{#hasProduces}}
        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [{{#produces}}
                    '{{{mediaType}}}'{{^-last}}, {{/-last}}{{/produces}}
                ]
            )
        {{/hasProduces}}

        {{#hasConsumes}}
        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [{{#consumes}}
                        '{{{mediaType}}}'{{^-last}}, {{/-last}}{{/consumes}}
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type
        {{/hasConsumes}}

        # authentication setting
        _auth_settings: List[str] = [{{#authMethods}}
            '{{name}}'{{^-last}}, {{/-last}}{{/authMethods}}
        ]

        return self.api_client.param_serialize(
            method='{{httpMethod}}',
            resource_path='{{{path}}}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


{{/operation}}
{{/operations}}
